# -*- coding: utf-8 -*-
"""
Created on Fri Mar  3 19:23:59 2023
This code is responsible for constructing the new features generated by symbolic regression
Input: A.csv file with labels in the first column and descriptors in the rest.
Output: A new.csv file is generated, the labels and features are unchanged, and the new features are added after the original features
@author: Administrator
"""
##Feature construction and given possible formulas (outputs an Excel file containing the formulas)
import numpy as np
import pandas as pd
import sympy
from pysr import PySRRegressor

data = pd.read_csv(r"test.csv", encoding ='gb2312')
data = data.iloc[:, 1:]

data.drop_duplicates(inplace=True)
data.index = range(data.shape[0])  #恢复打乱的索引


X = data.iloc[:,1:]
y = data.iloc[:,0]
#Processing of hardness data, since the hardness magnitude is higher than the composition, 
#this operation can make the generation of formulas more efficient, but the accuracy remains the same.
# y = y / 100 

model = PySRRegressor(
    niterations=1000,  # < Increase me for better results
    populations=8,
    # ^ Alternatively, stop after 24 hours have passed.
    maxsize=100,
    # ^ Allow greater complexity.
    maxdepth=20,
    precision=64,
    # ^ Higher precision calculations.
    binary_operators=["+", "-", "*", "/","^"],
    unary_operators=[
        "cos",
        "exp",
        "sin",
        "cube",
        "log10",
        "sqrt",
        "inv(x) = 1/x",

        # ^ Custom operator (julia syntax)
    ],
    extra_sympy_mappings={"inv": lambda x: 1 / x},
    denoise=True,
    # select_k_features=5,
    # ^ Define operator for SymPy as well
    # loss="loss(x, y) = abs(x - y)^0.5",
    loss= "LPDistLoss{3}()",
    # ^ Custom loss function (julia syntax)
)

model.fit(X, y)

print(model)
print(model.equations_)
model.equations_.to_csv("SRequations.csv") #Output formula


##Save the constructed features to the original dataset 
#(combine the original dataset and the computed data into the same csv file)
import pandas as pd
from sympy import *

# Read the first dataset
df1 = data

# Read the second dataset
df2 = pd.DataFrame(model.equations_["sympy_format"])

# Transform the formulas in the second dataset into computable Lambda functions
var_map = {col: Symbol(col) for col in df1.columns}
for idx, row in df2.iterrows():
    formula = lambdify(var_map.keys(), sympify(row['sympy_format']))
    df2.at[idx, 'formula'] = formula

# Calculate the formula and add the result to the first dataset
for idx, row in df1.iterrows():
    for idx2, row2 in df2.iterrows():
        formula = row2['formula']
        if callable(formula):
            result = formula(*row)
            # df1.at[idx, str(row2['sympy_format'])] = result
            df1.at[idx, f"result_{idx2}"] = result
        else:
            break
    else:
        continue
    break

# Save the results to a new Excel file
df1.to_csv("Addequations.csv")